# TGHack 2019

Sadly, I did not get to attend the event, but I'll try to create a writeup of some of the cooler challenges here, as they were so kind as to post the challenges after the competition ended.

## [RE // 50pt] Bytecodes

```bash
pip install uncompyle6
uncompyle6 main.pyc
```

Then simply copy the `print_flag` function into a repl, and run. (I had to change `chr(i ^ key)` to `chr(ord(i) ...`).

## [RE // 200pt] Gringotts Digitalization Project

We're handed a 64-bit ELF relocatable.

`checksec` reveals the following:

```
~/Documents/ctf/tghack2019/gringott   
❯ checksec pwn_module.ko 
[*] '/home/igor/Documents/ctf/tghack2019/gringott/pwn_module.ko'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
```

Let's see what the Ghidra tells us.

For this challenge, the disassembled assembly from IDA was much better than Ghidras, so I ended up using that instead.

The server isn't up, so I couldn't try further.

## [RE // 250pt] Cracking Magic

`file <file>`

```
key_check.elf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ac6bea7a2d5448a7f91876ffa04540f3f0da551e, stripped
```

`checksec <file>`

```
~/Documents/ctf/tghack2019/key_check   
❯ checksec key_check.elf 
[*] '/home/igor/Documents/ctf/tghack2019/key_check/key_check.elf'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

So we know it's going to be very hard to crack the program, so I guess keygen is the best way to proceed here.

Upon running the program, we're greeted by a prompt for a serial. Naturally, we don't know this, so let's open it in Ghidra and IDAFree.

Firstly, the program reads in 25 chars and replaces the newline with a `0x00` before jumping to a checking function.

Firstly, it checks to see if the user input now is 24 chars long, which is will be as we replaced the newline with a null-byte.

Then we enter `check 1`.

The pseudo-code generated by ghidra looks like this after a bit of modification;

```c
int check_for_whitespace(char *user_input)

{
  ushort **ppuVar1;
  size_t user_input_len;
  ulong i;
  
  i = 0;
  while( true ) {
    user_input_len = strlen(user_input);
    if (user_input_len <= i) {
      return 1;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(long)user_input[i]] & 8) == 0) break;
    i = i + 1;
  }
  return 0;
}
```

After googling the cryptic `__ctype_b_loc()`, we find that it returns a table of characteristics for characters, and we deduce
that this function checks to see if there is any whitespace in the string.

Now we only have the actual key checking left;

```c
      i = 0;
      while (i < 0xc) {
        uVar1 = FUN_0010098a(user_input[i],user_input[i + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        i = i + 2;
      }
      local_18 = 0xc;
      while (local_18 < 0x18) {
        uVar1 = FUN_001009ac(user_input[local_18],user_input[local_18 + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        local_18 = local_18 + 2;
      }
      ret_code = 1;
```
