# TGHack 2019

Sadly, I did not get to attend the event, but I'll try to create a writeup of some of the cooler challenges here, as they were so kind as to post the challenges after the competition ended.

## [RE // 50pt] Bytecodes

```bash
pip install uncompyle6
uncompyle6 main.pyc
```

Then simply copy the `print_flag` function into a repl, and run. (I had to change `chr(i ^ key)` to `chr(ord(i) ...`).

## [RE // 200pt] Gringotts Digitalization Project

We're handed a 64-bit ELF relocatable.

`checksec` reveals the following:

```
~/Documents/ctf/tghack2019/gringott   
❯ checksec pwn_module.ko 
[*] '/home/igor/Documents/ctf/tghack2019/gringott/pwn_module.ko'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
```

Let's see what the Ghidra tells us.

For this challenge, the disassembled assembly from IDA was much better than Ghidras, so I ended up using that instead.

The server isn't up, so I couldn't try further.

## [RE // 250pt] Cracking Magic

`file <file>`

```
key_check.elf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ac6bea7a2d5448a7f91876ffa04540f3f0da551e, stripped
```

`checksec <file>`

```
~/Documents/ctf/tghack2019/key_check   
❯ checksec key_check.elf 
[*] '/home/igor/Documents/ctf/tghack2019/key_check/key_check.elf'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

So we know it's going to be very hard to crack the program, so I guess keygen is the best way to proceed here.

Upon running the program, we're greeted by a prompt for a serial. Naturally, we don't know this, so let's open it in Ghidra and IDAFree.

Firstly, the program reads in 25 chars and replaces the newline with a `0x00` before jumping to a checking function.

Firstly, it checks to see if the user input now is 24 chars long, which is will be as we replaced the newline with a null-byte.

Then we enter `check 1`.

The pseudo-code generated by ghidra looks like this after a bit of modification;

```c
int check_for_whitespace(char *user_input)

{
  ushort **ppuVar1;
  size_t user_input_len;
  ulong i;
  
  i = 0;
  while( true ) {
    user_input_len = strlen(user_input);
    if (user_input_len <= i) {
      return 1;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(long)user_input[i]] & 8) == 0) break;
    i = i + 1;
  }
  return 0;
}
```

After googling the cryptic `__ctype_b_loc()`, we find that it returns a table of characteristics for characters, and we deduce
that this function checks to see if there is any whitespace in the string.

Now we only have the actual key checking left;

```c
      i = 0;
      while (i < 0xc) {
        uVar1 = FUN_0010098a(user_input[i],user_input[i + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        i = i + 2;
      }
      local_18 = 0xc;
      while (local_18 < 0x18) {
        uVar1 = FUN_001009ac(user_input[local_18],user_input[local_18 + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        local_18 = local_18 + 2;
      }
      ret_code = 1;
```

First things first, let's clean this up.

```c
      i = 0;
      while (i < 0xc) {
        fun1_ret = fun1(user_input[i],user_input[i + 1]);
        if ((int)fun1_ret == 0) {
          return 0;
        }
        i = i + 2;
      }
      j = 0xc;
      while (j < 0x18) {
        fun2_ret = fun2(user_input[j],user_input[j + 1]);
        if ((int)fun2_ret == 0) {
          return 0;
        }
        j = j + 2;
      }
      ret_code = 1;
```

We see that we want both of the functions to return `> 0`. Let's start with the first part, which works with the first part of the key `0x00 <= x <= 0xc`.

After cleaning up the parameters, we end up with this snippet;

```c
ulong fun1(char charA,char charB)
{
  return (int)(uint)((char)(charA ^ charB ^ 0x42U) < 'F');
}
```

(_`0x42U == 'B'`_)

Let's write some quick python to brute-force this (also included part two, as it's just the same logic).

```python
result = ''

def find_stage_1():
	for x in range(ord('A'), ord('Z')):
		for y in range(ord('A'), ord('Z')):
			if (x ^ y ^ 0x42) < ord('F'):
				return chr(x) + chr(y)


def find_stage_2():
	for x in range(ord('A'), ord('Z')):
		for y in range(ord('A'), ord('Z')):
			if (x ^ y ^ 0x13) > 0x1e:
				return chr(x) + chr(y)

for i in range(0, 0xc, 2):
	result += find_stage_1()	

for i in range(0xc, 0x18, 2):
	result += find_stage_2()	

print(result)
```

Now, we need 250 unique keys, so let's bruteforce that as well :)

Now, this is not a clean solution, but it works, in true CTF fashion.

```python
ones = []

for x in range(ord('A'), ord('Z')):
	for y in range(ord('A'), ord('Z')):
		if (x ^ y ^ 0x42) < ord('F') and len(ones) < 2:
			ones.append(chr(x) + chr(y))

ones = [x + y for x in ones for y in ones]
ones = [x + y for x in ones for y in ones]
ones = [x + y for x in ones for y in ones]
ones = [x[0:12] for x in ones]

twos = []

for x in range(ord('A'), ord('Z')):
	for y in range(ord('A'), ord('Z')):
		if (x ^ y ^ 0x13) > 0x1e and len(twos) < 2:
			twos.append(chr(x) + chr(y))

twos = [x + y for x in twos for y in twos]
twos = [x + y for x in twos for y in twos]
twos = [x + y for x in twos for y in twos]
twos = [x[0:12] for x in twos]

# print ','.join(ones)
# print ','.join(twos)

combos = []

for a in ones:
	for b in twos:
		combos.append(a + b)

print ', '.join(combos)

print "\n\n\n{}".format(len(combos))
```

Basically, I just create a few letter combos, and then concat them together. This gives 65536 results, which should be sufficient. Now, when I created this, I didn't factor in the fact that this creates a bunch of duplicates, but I managed to hack my way around it in the end.

What I ended up doing was the following:

```python
p = pwn.remote('keygen.tghack.no', 2222)

for i in range(250):
	print p.recv(1024)
	p.sendline(combos[i*250])

p.interactive()
```

There is no logic to this at all, but it works!

Flag acquired!

## [RE // 70pt] Elfish flag

ELF exec again. We open it in Ghidra and realize that it's just a fuzzed flag. Let's unfuzz!

Let's check out the function `flaggy` where the magic happens.

```c
  tg = 18260;
                    /* if str2 is a nullptr */
  if (str2 != (char *)0x0) {
    local_24 = 0;
    while (iVar1 = local_24 + 1, local_24 != 0) {
      uVar2 = (uint)(iVar1 >> 0x1f) >> 0x1f;
      abStack24[(long)iVar1] = tg[(long)(int)((iVar1 + uVar2 & 1) - uVar2)] ^ str2[(long)iVar1];
      local_24 = iVar1;
    }
  }
  i = 0;
  while( true ) {
    if ((uint)(byte)input[(long)i] + 100 != (uint)(byte)str1[(long)i]) break;
    i = i + 1;
  }
  if (i == 0x19) {
    printf("Congratz, you found the flag!");
  }
```
  
**This** is where the magic happens.

But when reading this, something stood out to me. Input is never modified :think:. So, what happens if we take str1, and subtract 100 from every codepoint? Well, we get the flag. This was an easy task after all! :)
