# [70 points] CoppeRSA Lattice

My first reaction was that this title looked a lot like a huge hint, so I googled "Copper RSA Lattice" and quite quickly found
"Coppersmith's attack" and Lattice based attacks (LLL). The best resource I found on this was [this one from cr.yp.to](https://latticehacks.cr.yp.to/rsa.html).

We then have to find out which of the two attacks to use;

1. Coppersmith's small public RSA exponent attack with partially known message
2. Coppersmith's attack for factoring with bits of p known

This was not immediately clear to me, and took some tinkering to solve. In hindsight, I think this would be a lot easier
if I had some background knowledge of number theory.

We're given some data in the challenge;

```sage
# INFO
import random
import math

base = random.getrandbits(2048)

p = next_prime(base + random.getrandbits(256))
q = next_prime(base + random.getrandbits(256))
n = p * q

e = 65537

print("e = ", e)
print("n = ", n)
c = power_mod(m, e, n)
print("c = ", c)

e = 65537

# OUTPUT
n = 8281850967132278399574272688766937486036646313403007679588335903785669628431708760927341727806006769095252325575815709840401878674105658204057327337750902945521512357960818523078486774689928139816732080923197367563639383252762498921096166065153092144335239373370093976823925031794323976150363874930075228846801224430767428594024165529140949082062667410186456029480046489969338885725614510660737026927443934115006027747874368836800022473917576424175601374800697491622086825964475396316066082109998646438504664272000556702241576240616765962934452557847306066736505798267513078073147161755828577875047115978481485076227911405625234425533967247248864837854031634968764570599279385827285321806293661331225163255461894680337693227417748934924109356565823327149859245521513696171473417470936260563397398387972467438182651142096935931112668743912944902147582538985769095457203775208567489073198557073226907349118348902079942096374377432431441166710584381655348979330535397040250376989291669788189409825278457889980676574146044704329826483808929549888234303934178478274711686806257841293265249466735277673158607466360053037971774844824065612178793324128914371112619033111301900922374201703477207948412866443213080633623441392016518823291181
c = 6407923537926201847312357068295079879508779752068254604904486842729636773279241546432035102141932853761974844472828552921133743850412718722424893044377874567625621282274625365299685502104113862870672461666586814138206797733946319875258776059721304226419810313489197076949529322847815009706727586961448584443159011118432142946962961532154723891985416387650240762711716865116844837968079333914181751979527853152286708153252001832721723040664452442266930832118353632114958540067674924812749763008217133300059446967170825813909142247660230309955433005706793802514554628379255160648976960069078223370104177403453404917998945232459801324103878906593528309460372271638119657797804398399482025063414403804134607772871958848100256643503372624214762343403925077455660522664025602043433142314759978192969519687720668535544914589329155338178120703060384042066182354031274600184116143293639032906542194564776766076911767759167772137229504115598174156646085123675283692418970988032320780636742598466655712520383055569607154074137271584433653335176877094399371749081016317705026349554938167377640856287458145646649292278971980553895419112860061073864077521131958519819285117031990498977039003918710661660868949818362940359852436185282868088342132
```

Which I by some googling found out to be `sage` code (because of the `next_prime` and `power_mod` calls), and I ended up using `sage` to solve this.

I then started thinking of how I could apply this knowledge to the attack vectors.

After quite some time I realised that it might be possible to retrieve some common information about `p` and `q`, as they
both are created from `base`. I then tried to execute some python code to check my theory;

```python-repl
>>> import random
>>> base = random.getrandbits(2048)
>>> base ** 2
69374776612424460595140625404112962209621745381444850893691312713555741245945102174307077406553442429897296637163708035970194023585897965478064375387505835143286366886624955950298786393860182065655419410515123515658810991058920883331365888379144786176983629495563599442093805176003098721219545918382149187225236142989883774505939764997385800919079539759314813433883238371545313584376620421384082042810400934851479767310118475166707990918714422074874550822548944272107962714300246526995228851316582426204252369595759294139257243446771709707206141521236697684091231037866600805998226146489656425862174494323745774653637849841673957944751855792540818679304059076681930105446793072945438159651056730340408887967620556987561055317202295217004755823229702532573216439819101342432479084054023686701918925810982735560960277424563799675098787748223679862200866999547032470594027824903986216308707081568250802991831801304507484895717037866804456865498218495719594385864233380057603875817850136174895213286752888515184836088661117843540299042503608674374569949900718272350514906674181159743745791439536663050872110396006467801762544859552996949996229513160748758954792337679230080029512707091362757304824802500539206267951702356023937858569281
>>> p = base + random.getrandbits(256)
>>> q = base + random.getrandbits(256)
>>> p*q
69374776612424460595140625404112962209621745381444850893691312713555741245945102174307077406553442429897296637163708035970194023585897965478064375387505835143286366886624955950298786393860182065655419410515123515658810991058920883331365888379144786176983629495563599442093805176003098721219545918382149187225236142989883774505939764997385800919079539759314813433883238371545313584376620421384082042810400934851479767310118475166707990918714422074874550822548944272107962714300246526995228851316582426204252369595759294139257243446771709707778633856903886723583917520591364715815954629442480710411182641997044188024364407557524587456628314649448126254187128439268125281691818247616107087896767099634141240331896214667594633672323859658115954282277217540033696820015495774534714134200068932068074339066157333544315151675255947255201352377627527590240818149299184337482457183457963567299861361961844869885191753558142139244996397170059534258642914026889274018058887237302245454892005867791748911219022461985473505842718432833258604085685372610307835865953347370109473506470038188367484404510272324756169831539275782657789985144281926681285773720510155057377294105008663165456617817998041617530955079924799275244740637142197782735849714
>>> base
8329152214506855834900685281601703927850381244371838572092622120228553193917908789417177224077120470331464819532102609610512754667128739812739489750248863209236060364460318223736904495021269413432641337220873657500646767231827621841168353822937452958404658826232004012777688509220337297799426586697274348015015447622157041491327142132600707933207186792603302454087306986461683405373039352183326083874300619476499545011333260018031825022264519752281458084876790969607982734310757809279591077592644004902991494688011266026147993465549527690913532510704955965385955360360546396247689201868321689056583266927766144008159
```

As you can see, there is a clear correlation in the higher-order bits of `p*q` and `base ** 2`, and thus we can apply
the 2nd variation of the Coppersmith attack.

I did this in sage notebook;
![Sage scrnsht](https://github.com/FredrikAugust/ctf-writeups/blob/master/ctflearn/Screenshot%202020-01-06%20at%2019.03.58.png)

I simply guessed that the last 256 bits would be unknown, but it worked fine. With this I had `p`, `n`, `e`, and `c`, and
I could use `RsaCtfTool.py` to decipher the message!
